#pragma once
#include <memory>
#include <any>
#include "MiniMLBaseVisitor.h"   // generated by ANTLR
#include "../ast/Nodes.hpp"      // your EVar, ELitInt, ELam, EApp, ELet, EIf

namespace miniml {

    class AstBuilder : public MiniMLBaseVisitor {
    public:
        using Ptr = ExprPtr;

        std::any visitProg(MiniMLParser::ProgContext* ctx) override {
            return visit(ctx->expr());
        }

        std::any visitLetExpr(MiniMLParser::LetExprContext* ctx) override {
            auto name = ctx->ID()->getText();
            auto rhs  = asExpr(visit(ctx->expr(0)));
            auto body = asExpr(visit(ctx->expr(1)));
            return Ptr(let_(name, rhs, body));
        }

        std::any visitIfExpr(MiniMLParser::IfExprContext* ctx) override {
            auto c = asExpr(visit(ctx->expr(0)));
            auto t = asExpr(visit(ctx->expr(1)));
            auto e = asExpr(visit(ctx->expr(2)));
            return Ptr(if_(c, t, e));
        }

        std::any visitLamExpr(MiniMLParser::LamExprContext* ctx) override {
            auto x = ctx->ID()->getText();
            auto b = asExpr(visit(ctx->expr()));
            return Ptr(lam(x, b));
        }

        std::any visitAppChain(MiniMLParser::AppChainContext* ctx) override {
            // appExpr: atom (atom)+
            Ptr f = asExpr(visit(ctx->atom(0)));
            for (size_t i = 1; i < ctx->atom().size(); ++i) {
                Ptr a = asExpr(visit(ctx->atom(i)));
                f = app(f, a); // left-assoc: (((f a1) a2) ...)
            }
            return f;
        }

        std::any visitJustAtom(MiniMLParser::JustAtomContext* ctx) override {
            return visit(ctx->atom());
        }

        std::any visitAtom(MiniMLParser::AtomContext* ctx) override {
            if (ctx->INT()) return Ptr(lit_int(std::stol(ctx->INT()->getText())));
            if (ctx->ID())  return Ptr(var(ctx->ID()->getText()));
            // '(' expr ')'
            return asExpr(visit(ctx->expr()));
        }

    private:
        static Ptr asExpr(const std::any& a) {
            if (!a.has_value()) return nullptr;
            return std::any_cast<Ptr>(a);
        }
    };

} // namespace miniml
